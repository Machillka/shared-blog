# 线程和进程

简述一下之间的区别与联系 （假设使用时间片轮转的抢占式调度方式）

## 进程

首先，我们写的代码存储在硬盘的静态文件中，接着被编译成二进制的可执行文件。在运行该可执行文件的时候，它被丢到内存里，然后 CPU 按顺序执行丢到内存中的指令。

那个被丢到内存中一整个被CPU执行的东西，被称为==进程==。比如我们同时打开了浏览器，笔记软件和声破天，就相当于现在计算机在运行三个进程（仅指前台）

单核一次只能执行一个进程，那么，如果一直等待一个进程结束之后再执行另一个进程，就会变得很不妙（想象一下，如果计算机只能等待每一个进程执行结束之后再执行下一个 —— 打字的时候就无法使用其他软件了，因为处理打字信息也是一个进程，我们需要等待打字全部结束之后才可以访问其他进程，~~电脑废了~~

所以就需要引入进程的控制

### 并发

简单来说，就是**单核**、在多个程序间交替执行。比如我们需要把两辆车搬回家，一种方式是先开 A 车到家，再开 B 车到家。另一种**并发**的方式就是先把 A 车开 10m，再把 B 车开 10m，这样交替执行。假设我们把 A 和 B 开的距离无线缩短并且忽略切换车辆的时间，那么*宏观*上就好像 A と B 是同时前进了。

### 并行

还是 A 和 B 车，但是现在富有的我请代驾帮忙把 B 车开回家，同时我也把 A 车开回家。这个就是并行 —— **多核**执行**多进程**（真正的把**多个进程同时运行**

关于并发和并行的内容可能后面会再开一个 doc 详细说明，在此处先简略一下。


### 具体执行

既然需要在不同的进程中不断跳转（分时控制）
就需要考虑两件事情 ——
- 如何切换进程 —— 上下文切换机制
- 如何选择要切换的进程 / 何时切换进程 —— 调度策略

> 操作系统通过调度策略决定切换时机，通过上下文切换机制完成切换进程的操作

#### 上下文切换机制

要切换进程，肯定不是简单的直接丢掉不做，而要考虑两件事情——
1. 保存当前的进程状态
2. 恢复待执行的进程状态

所以一个进程一般有以下状态 ——
- 就绪状态：标记可以运行，但是还没运行（没有被分配时间片，在等待被调度）
- 运行状态：被赋予了时间片，开始执行
- 阻塞状态：为了等待某事件发生而暂停运行（有点像挂起？），比如触发了同步的IO流操作等，为了等待IO操作的完成，于是会被标记为阻塞状态
现代操作系统中可能会有更复杂的状态，但是上面三个的互相转化是基础

#### 控制结构

引入了一个数据结构 **PCB**（Process Control Block）来描述进程的运行，其中包含很多信息，如
- 进程描述信息
- 进程控制和管理信息
- 资源分配信息
- CPU 相关信息

最后通过链表或者索引表的形式来组成各种状态队列来依次执行

## 线程

比进程更小的基本运行单位，可以把进程中每一个小的执行流看成一个线程（thread）。

同进程内的多个线程之间共享一定的资源（全局变量、文件等），但是每一个线程都有自己**独立**的寄存器和栈，以保证线程之间的相对独立。

线程同样也可以==并发==，同时使用了 **TCB** （Thead Control Block）来描述一个线程的运行。

## 举点例子

1. 现在有两个核心和一个支持多线程的任务。假设我们不采用多线程的开发方式，只是让一个单核同步运行，那么比较慢；但是如果这个多线程之间**不冲突**，那么理论上可以用两个核心同时执行程序，使得该进程的执行速度减半。
2. 现在有若干核心和一个单线程任务，那么，此时执行该任务所花费的时间就与核心数量无关，因为不论有多少核心，只能分配一个来给单线程任务执行。

可能还有其他例子，但是综上所述，可以发现，线程其实是 CPU **调度**的最小单位，而进程可以看作分配**资源**的最小单位。

## 发现问题

如果线程之间有 竞争 / 依赖 关系怎么办？
生活化的例子 ——

## 区别与联系


## 写在最后

但是我们在生产生活实际当中，还要考虑到调度算法的复杂度，以及轮换所消耗的时间，所以其实多线程不一定会比单线程跑的快