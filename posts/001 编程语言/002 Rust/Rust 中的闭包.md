# Rust 中的闭包

## 闭包

> **闭包**是由捆绑起来（封闭的）的函数和函数周围状态（**词法环境**）的引用组合而成。换言之，闭包让函数能访问它的外部作用域 —— [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Closures))

形式上看，闭包是一个内层函数可以访问外层函数中的局部变量并且外层函数需要返回内层函数的引用的函数。

那么从内核上看，闭包的操作，使得一个局部变量的生命周期不再是一个函数执行完毕之后 —— 因为闭包包含了函数声明所在的词法环境（其中包含了该函数作用域下的所有局部变量），而闭包函数返回的函数实例的引用也包含了一份局部变量的引用，所以可以继续使用其局部变量。

所以一个好的闭包设计有点类似 OO —— 把数据和函数关联在一起（封装），从而可以实现一个函数族（有点像一个函数工厂，可以生成多个类似但不同的函数）

## Rust 下闭包

Rust 中的闭包是一种匿名函数（使用匿名函数实现闭包）

假设有一个有参匿名函数 —— 那么在使用这个有参匿名函数的时候不就正好捕获了匿名函数上层作用域中的局部变量吗？？恰好就是闭包的定义。

例子 ——
```rust
let x: i32 = 3;
let plus_x = |y: i32| y + x;
let num: i32 = 5;
println!("{0} + {1} = {2}",num, x, plus_3(num));
```
`plus_x`这个函数访问了局部变量`x`，但是`x`又不是`plus_x`的参数，所以说这个匿名函数捕获了捕获作用域中的值，非常的妙

当然，由于这是 rust 所以自然不会这么轻松，我们依旧需要强调值的所有权等信息💦💦💦